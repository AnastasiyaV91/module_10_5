import datetime         # Импортируем модуль datetime для вычисления времени работы программы

#  ---------------------- Линейный метод (запускать отдельно от многопроцессного метода) ------------------------

def read_info(name):                     # Функция принимает список адресов файлов
    all_data = []                        # Создаем пустой локальный список
    start1 = datetime.datetime.now()     # Сохраняем текущее время начала работы программы
    for i in name:                       # Цикл по каждому файлу
        with open(i, 'r') as file:       # Открываем каждый файл в режиме чтения
            while True:                  # БЕСКОНЕЧНЫЙ ЦИКЛ
                line = file.readline()   # Построчно считываем каждую строку в файле
                all_data.append(line)    # Добавляем каждую строку в локальный список
                if not line:             # Если строки нет, то
                    break                # выходим из цикла
    stop1 = datetime.datetime.now()      # Сохраняем текущее время окончания работы программы
    print(stop1-start1)                  # Высчитываем время работы программы и выводим в консоль

filenames = [f'./file {number}.txt' for number in range(1, 5)]  # Список адресов файлов .TXT в текущей папке
read_info(filenames)                                            # Вызов функции read_info

# -------------------------- Многопроцессный метод (запускать отдельно от линейного метода) -------------------

import multiprocessing                   # Импортируем модуль для многопроцессного метода
def read_info(name):                     # Функция принимает адрес файла
    all_data = []                        # Создаем пустой локальный список
    with open(name, 'r') as file:        # Открываем файл в режиме чтения
        while True:                      # БЕСКОНЕЧНЫЙ ЦИКЛ
            line = file.readline()       # Построчно считываем каждую строку в файле
            all_data.append(line)        # Добавляем каждую строку в локальный список
            if not line:                 # Если строки нет, то
                break                    # выходим из цикла

if __name__ == '__main__':   # Проверка на то, что файл, который запускается, является основным (слова из видеолекции)
    with multiprocessing.Pool(processes=5) as pool:     # Pool принимает количество процессов, которые нужно запустить.
                                                        # with в дополнение обрабатывает ошибки
        files = [f'./file {number}.txt' for number in range(1, 5)]  # Список адресов файлов .TXT в текущей папке
        start2 = datetime.datetime.now()                            # Сохраняем текущее время начала работы программы
        pool.map(read_info, files)                                  # Метод map прогоняет список с адресами файлов
                                                                    # через функцию read_info в разных процессах
                                                                    # одновременно

    stop2 = datetime.datetime.now()     # Сохраняем текущее время окончания работы программы
    print(stop2 - start2)               # Высчитываем время работы программы и выводим в консоль